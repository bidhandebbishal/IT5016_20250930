# ========================================
# PART B TASK 1
# Requisition System using OOP in Python
# ========================================

class RequisitionSystem:
    # Class Variables (shared by all objects)
    counter = 10000                 # K.I.S.S because it is simple way to generate unique IDs
    total_submitted = 0             # Single Responsibility because it only tracks submitted requisitions
    total_approved = 0              # Cohesion because statistics are grouped logically
    total_pending = 0
    total_rejected = 0
    all_reqs = []                   # Reusability because all requisitions are stored for later access
    
    def __init__(self):
        RequisitionSystem.counter += 1  # DRY because the ID logic is reused for all objects
        self.req_id = RequisitionSystem.counter
        self.status = "Pending"         # Encapsulation because default values are hidden inside class
        self.approval_ref = ""
        self.total = 0
        
        # SRP because each method below does a single job
        self.get_staff_info()
        self.get_items()
        self.check_approval()
        
        # Maintainability because statistics are updated in one place
        RequisitionSystem.total_submitted += 1
        RequisitionSystem.all_reqs.append(self)
    
    def get_staff_info(self):
        # Abstraction because user doesn’t see how data is stored internally
        self.date = input("Enter the date of requisition (DD/MM/YYYY): ")
        self.staff_id = input("Enter Staff ID: ")
        self.staff_name = input("Enter Staff Name: ")
        
        # K.I.S.S because output is kept simple and easy to read
        print("\nPrinting Staff Information:")
        print(f"Date: {self.date}")
        print(f"Staff ID: {self.staff_id}")
        print(f"Staff Name: {self.staff_name}")
        print(f"Requisition ID: {self.req_id}")
    
    def get_items(self):
        # Single Responsibility because this method only handles item entry and totals
        num_items = int(input("How many items do you want? "))
        
        total = 0
        for i in range(num_items):
            item = input(f"Enter item {i+1} name: ")    # Extensibility because this could be expanded to store items
            price = float(input(f"Enter price: $"))
            total += price                              # K.I.S.S because accumulation logic is simple
        
        self.total = total
        print(f"${self.total}")
    
    def check_approval(self):
        # Abstraction because approval rules are hidden in this method
        print(f"Total: ${self.total}")
        
        if self.total < 500:   # K.I.S.S because rule is simple and easy to understand
            self.status = "Approved"
            last_three = str(self.req_id)[-3:]
            self.approval_ref = self.staff_id + last_three
            print(f"Status: {self.status}")
            print(f"Approval Reference Number: {self.approval_ref}")
            RequisitionSystem.total_approved += 1
        else:
            # Extensibility because rule can be changed easily (e.g., 500 → 1000)
            self.status = "Pending"
            print(f"Status: {self.status}")
            RequisitionSystem.total_pending += 1
    
    def manager_decision(self, decision):
        # Single Responsibility because this only manages manager overrides
        if self.status == "Pending":
            RequisitionSystem.total_pending -= 1
            if decision.lower() == "approved":
                self.status = "Approved"
                last_three = str(self.req_id)[-3:]
                self.approval_ref = self.staff_id + last_three
                RequisitionSystem.total_approved += 1
            else:
                self.status = "Not Approved"
                RequisitionSystem.total_rejected += 1
    
    def show_details(self):
        # K.I.S.S because output is straightforward and clear
        print(f"\nRequisition Details:")
        print(f"Date: {self.date}")
        print(f"ID: {self.req_id}")
        print(f"Staff: {self.staff_name} ({self.staff_id})")
        print(f"Total: ${self.total}")
        print(f"Status: {self.status}")
        if self.approval_ref:  # Abstraction because user doesn’t know how approval ref is generated
            print(f"Approval Reference: {self.approval_ref}")
    
    def show_statistics():
        # DRY because statistics display is centralized in one method
        # Cohesion because all requisition stats are kept inside this class
        print("\nStatistics:")
        print("Displaying the Requisition Statistics")
        print(f"The total number of requisitions submitted: {RequisitionSystem.total_submitted}")
        print(f"The total number of approved requisitions: {RequisitionSystem.total_approved}")
        print(f"The total number of pending requisitions: {RequisitionSystem.total_pending}")
        print(f"The total number of not approved requisitions: {RequisitionSystem.total_rejected}")


# ========================================
# PART B TASK 2
# ========================================
if __name__ == "__main__":
    # K.I.S.S because program execution flow is kept simple and sequential
    print("Creating first requisition:")
    req1 = RequisitionSystem()
    req1.show_details()
    
    print("\n" + "="*50)
    print("Creating second requisition:")
    req2 = RequisitionSystem()
    req2.show_details()
    
    print("\n" + "="*50)
    print("Creating third requisition:")
    req3 = RequisitionSystem()
    req3.show_details()
    
    print("\n" + "="*50)
    print("Creating fourth requisition:")
    req4 = RequisitionSystem()
    req4.show_details()
    
    # DRY because statistics are shown by reusing the same method
    RequisitionSystem.show_statistics()
    
    print("\n" + "="*50)
    print("Manager decisions for pending requisitions:")
    for req in RequisitionSystem.all_reqs:
        if req.status == "Pending":
            # Extensibility because manager input allows flexible decision-making
            decision = input(f"\nManager decision for {req.staff_name}'s request (Approved/Not Approved): ")
            req.manager_decision(decision)
    
    # Maintainability because statistics update in one place after decisions
    print("\n" + "="*50)
    RequisitionSystem.show_statistics()
